<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer4：二维数组中的查找</title>
      <link href="/2021/04/30/%E5%89%91%E6%8C%87offer4%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/04/30/%E5%89%91%E6%8C%87offer4%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指offer4：二维数组中的查找"><a href="#剑指offer4：二维数组中的查找" class="headerlink" title="剑指offer4：二维数组中的查找"></a>剑指offer4：二维数组中的查找</h2><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p> 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下的递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><span id="more"></span><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p> 分析这个问题，最开始我会把二维数组当成一个矩形，然后从数组中选取一个数字，分3种情况来分析查找的过程。当数组中选取的数字刚好与要查找的数字相等时，就结束查找过程。</p><ul><li>如果选取的数字小于要查找的数字，根据数组排序顺序，下一步应该选取当前位置的右边或者下边；</li><li>如果选取的数字大于要查找的数字，那么要查找的数字应当在当前位置的上边或者左边。</li></ul><p>这就有一个问题，两组数字选择的位置会有重叠的部分，所以这个方法不太可行。</p><p> 那么优化这个问题的关键就在于<strong>如何使得两次选取的数字范围是不重合的</strong>，所以我们每次从数组中选择出来的数字最好要是一定范围的边界，例如一直和右上角的数字进行比较。</p><ul><li>如果右上角的数字比目标数字大的话，那么就可以把最后一列给剔除出去；</li><li>如果由右上角的数字比目标数字小的话，那么可以把第一行剔除出去；</li><li>接着从剩下的矩形阵列里的右上角找就行了。</li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[][] arr,<span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> arr[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; row &amp;&amp; column &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(target == arr[i][column - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; arr[i][column - <span class="number">1</span>]) &#123;</span><br><span class="line">i ++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">column --;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p> 此题的思路关键就在于找到所选择的数字的过程要每一次都能够排除一些元素，这就说明这个数字一定是某一行或某一列最大或者最小值（处于边界位置），只有这样才可以在选择的时候很好地排除。所以理所当然地可以通过每次比较“矩形”中的角上的元素来查找目标元素，得到答案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2021/04/29/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/04/29/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p> 首先，堆排序是对树这一数据结构的排序应用。他的具体思路如下：</p><p> 大顶堆是升序排序，小顶堆是降序排序。因为堆排序属于将数组以二叉树的形式来思考。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 以大顶堆为例，从左往右，从下至上，对每个非叶子结点进行比较，将其与左右子树进行比较，将大的值放到该位置，</span><br><span class="line">- 接着对下一个结点进行比较，最后最大的值将位于大顶堆的顶部；</span><br><span class="line">- 将其放在数组的最后一个位置，对剩下的数据继续进行堆排序。</span><br></pre></td></tr></table></figure><p>堆排序类似于选择排序，对于大顶堆，每次选择最大的数据，但是堆排序会减少比较的次数，最好最坏平均的时间复杂度都是O(nlong)。</p><hr><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">heapSort(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//adjustHeap(arr, 1, arr.length);</span></span><br><span class="line"><span class="comment">//adjustHeap(arr, 0, arr.length);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">adjustHeap(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j --) &#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = temp;</span><br><span class="line">adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：完成将以i对应的非叶子结点的树调整成大顶堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待调整的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 非叶子结点在数组中的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 表示对多少个元素继续调整，length在逐渐减少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> length)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i]; <span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line"><span class="comment">//开始调整</span></span><br><span class="line"><span class="comment">//1.k = i * 2 + 1,k是i的左子结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;  <span class="comment">//找到子结点中最大的值</span></span><br><span class="line"><span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;  <span class="comment">//说明左子结点的值小于右子结点的值 </span></span><br><span class="line">k ++;  <span class="comment">//k指向右子结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(arr[k] &gt; temp) &#123;    <span class="comment">//如果子结点的值大于父结点</span></span><br><span class="line">arr[i] = arr[k];   <span class="comment">//把较大的值赋给当前结点</span></span><br><span class="line">i = k;             <span class="comment">//i指向k，继续比较</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><p> 由于堆排序采用了树的数据结构，每次的比较次数都和长度有关，所以他的最好最坏和平均的时间复杂度都是同一个，即O(nlogn)。</p><p>算法稳定性：</p><p> 堆排序在交换元素的时候可能会破坏稳定性，所以堆排序是<em><strong>不稳定的</strong></em>排序算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式详解</title>
      <link href="/2021/04/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/04/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式之单例模式详解"><a href="#设计模式之单例模式详解" class="headerlink" title="设计模式之单例模式详解"></a>设计模式之单例模式详解</h2><p>单例模式是Java中最简单的设计模式之一。它属于创建型模式，提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责自己创建对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。</p><span id="more"></span><p><strong>Attention：</strong></p><ul><li>1.单例类只能有一个实例。</li><li>2.单例类必须自己创建唯一的实例。</li><li>3.单例类必须给所有其他对象提供这一实例。</li></ul><hr><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>**意图：**保证一个类只能有一个实例，并且提供一个访问它的全局访问点。</p><p>**主要解决：**一个全局使用的类频繁地创建与销毁。</p><p>**何时使用：**当想控制实例数目，节省资源的时候。</p><p>**如何解决：**判断系统是否已经有了这个单例，如果有则返回，没有则创建。</p><p>**关键代码：**构造函数是私有的。</p><p>**优点：**在内存中只有一个实例，减少了内存的开销，尤其是频繁地创建和销毁实例；避免对资源的多重占用（比如写文件操作）。</p><p>**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><hr><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p><strong>步骤一</strong></p><p>创建一个Singleton类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建SingleObject的一个对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleObject</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleObject</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//让构造函数为private，这样该类就不会被实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleObject</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取唯一可用对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤二</strong></p><p>从Singleton类获取唯一的对象使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这是不合法的构造函数，编译时错误，因为构造函数SingleObject是不可见的</span></span><br><span class="line">        <span class="comment">//SingleObject object = new SingleObject();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取唯一可用的对象,调用类的静态方法</span></span><br><span class="line">        <span class="type">SingleObject</span> <span class="variable">object</span> <span class="operator">=</span> SingleObject.getInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取消息</span></span><br><span class="line">        object.showMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h4><h5 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1.懒汉式，线程不安全"></a>1.懒汉式，线程不安全</h5><p>**是否lazy初始化：**是</p><p>**是否多线程安全：**否</p><p>**实现难度：**易</p><p> 这种方式是最基本的实现方式，最大的问题就是不支持多线程。因为没有加锁synchronized，所以严格意义上它不算单例模式。这种方式lazy loading很明显，不要求线程安全，在多线程不能正常工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-懒汉式，线程安全"><a href="#2-懒汉式，线程安全" class="headerlink" title="2.懒汉式，线程安全"></a>2.懒汉式，线程安全</h5><p>**是否lazy初始化：**是</p><p>**是否多线程安全：**是</p><p>**实现难度：**易</p><p> 这种方式具备很好的lazy loading，能够在多线程中很好地工作，但是效率比较低，99%的情况下不需要同步。</p><p>**优点：**第一次调用才初始化，避免内存浪费。</p><p>**缺点：**必须枷锁synchronized才能保证单例，但是加锁会影响效率。</p><p>getInstance()的性能对应用程序不是很关键，因为该方法不会使用得太过频繁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instanvce == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3.饿汉式"></a>3.饿汉式</h5><p>**是否lazy初始化：**否</p><p>**是否多线程安全：**是</p><p>**实现难度：**易</p><p> 这种方法比较常用，但是很容易产生垃圾对象。它基于classloader机制避免了多线程的同步问题，不过，instance在类装载时就实例化了，虽然导致类装载的原因很多，在单例模式中大多数都是调用了getInstance的方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。</p><p>**优点：**没有加锁，执行效率会比较高。</p><p>**缺点：**类加载时就初始化了，浪费内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        retutn instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-双检锁-双重校验锁（DCL，即double-checked-locking）"><a href="#4-双检锁-双重校验锁（DCL，即double-checked-locking）" class="headerlink" title="4.双检锁&#x2F;双重校验锁（DCL，即double-checked locking）"></a>4.双检锁&#x2F;双重校验锁（DCL，即double-checked locking）</h5><p>**是否lazy初始化：**是</p><p>**是否多线程安全：**是</p><p>**实现难度：**较复杂</p><p> 这种方式采用双锁机制，安全且在多线程环境下能保持高性能，getInstance()的性能对应用程序很关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">SingletongetSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-登记式-静态内部类"><a href="#5-登记式-静态内部类" class="headerlink" title="5.登记式&#x2F;静态内部类"></a>5.登记式&#x2F;静态内部类</h5><p>**是否lazy初始化：**是</p><p>**是否多线程安全：**是</p><p>**实现难度：**一般</p><p> 这种方式可以达到双检方式一样的功效，但是实现更加简单。对静态域使用延迟初始化，应使用这种方式而不是双检索方式。这种方式只适用于静态域的情况，双检索方式可在实例域需要延迟初始化时使用。</p><p> 这种方式同样利用了classloader机制来保证初始化instance时只有一个线程，它与第三种方式不同的是：第三种方式只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading的效果），而这种方式是Singleton被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有通过显式装载SingletonHolder类，从而实例化instance。</p><p> 如果实例化instance很消耗资源，所以会想让它延迟加载，另外一方面，又不希望在Singleton类加载时就实例化，因为不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance明显是不合适的。这个时候，这种方式相比第三种方式就显得更加合理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singletoon</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6.枚举"></a>6.枚举</h5><p>**JDK版本：**JDK1.5起</p><p>**是否lazy初始化：**否</p><p>**是否多线程安全：**是</p><p>**实现难度：**易</p><p> 这种方式我还没有用过，但是据说是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是Effective Java作者Josh Bloch提倡的方式，它不仅可以避免多线程同步的问题，而且还支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于JDK1.5之后才加入enum特性，用这种方式写感觉比较生疏，在实际工作中也很少用。不能通过reflection attack来调用私有构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> 一般情况下，第一种懒汉式的因为线程不安全，在多线程中不能正常工作，而第二种懒汉式的虽然可以在多线程环境中正常工作，但是由于加锁时间效率会很低。所以建议使用第三种饿汉式，通过静态构造函数确保只调用一次。只有在明确实现lazy loading效果时，才会使用第五种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第6种枚举方式。如果有其他的特殊需求，再考虑使用第4种双检锁方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总则</title>
      <link href="/2021/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E5%88%99/"/>
      <url>/2021/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式总则"><a href="#设计模式总则" class="headerlink" title="设计模式总则"></a>设计模式总则</h2><p> 在最开始学编程的时候，还不了解什么是设计模式，就觉得我能把程序写出来，完成它应该实现的功能就行了。在后面学习到数据结构和算法的时候了解了时间复杂度和空间复杂度，开始发现代码并不仅仅只是实现功能这么简单，在实现功能的同时，优化时间复杂度和空间复杂度，甚至是平衡两者之间的关系都具有着很大的挑战性，他会让程序拥有更好的性能，同时也使得自己对编程语言的使用能更上一层楼。</p><span id="more"></span><p> 在后面接触到项目之后，单例模式、工厂模式等的运用让我发现设计模式代表了最当前佳的实践，通过设计模式可以重用代码，让代码更容易被理解，保证了代码的可靠性。项目之中合理利用设计模式确实有着非常之高的效率。于此，打算记录一下对设计模式学习的文档及自己的思考。</p><hr><p> 设计模式一共有23种，这些总共可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Pattterns）。除此之外，还有另一类设计模式，J2EE设计模式。</p><hr><p> 创建型设计模式包括：工厂模式（Factoty Pattern）、抽象工厂模式（Abstract Factory Pattern）、单例模式（Singleton Pattern）、建造者模式（Builder Pattern）、原型模式（Prototype Pattern）。</p><p> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断某个给定实例需要创建哪些对象时更加灵活。</p><hr><p> 结构性设计模式包括：适配器模式（Adapter Pattern）、桥接模式（Bridge Pattern）、过滤器模式（Filter、Criteria Pattern）、组合模式（Composite Pattern）、装饰器模式（Decorator Pattern）、外观模式（Facade Pattern）、享元模式（FlyWeight Pattern）、代理模式（Proxy Pattern）。</p><p> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><hr><p> 行为型模式包括：责任链模式（Chain ofResponsibility Pattern）、命令模式（Command Pattern）、解释器模式（Interpreter Pattern）、迭代器模式（Iterator Pattern）、中介者模式（Mediator Pattern）、备忘录模式（Memento Pattern）、观察者模式（Observer Pattern）、状态模式（State Pattern）、空对象模式（Null Object Pattern）、策略模式（Strategy Pattern）、模板模式（Template Pattern）、访问者模式（Visitor Pattern）。</p><p> 这些模式特别关注对象之间的通信。</p><hr><p> J2EE设计模式包括：MVC模式（MVC Pattern）、业务代表模式（Business Delegate Pattern）、组合实体模式（Composite Entity Pattern）、数据访问对象模式（Data Access Object Pattern）、前端控制器模式（Front Controller Pattern）、拦截过滤器模式（Intercepting Filter Pattern）、服务定位器模式（Service Locator Pattern）、传输对象模式（Transfer Object Pattern）。</p><p> 这些设计模式特别关注表示层。这些模式是由Sun Java Center鉴定的。</p><hr><p><strong>设计模式的六大原则</strong><br><strong>1、开闭原则（Open Close Principle）</strong><br>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用<strong>接口和抽象类</strong>，后面的具体设计中我们会提到这点。<br><strong>2、里氏代换原则（Liskov Substitution Principle）</strong><br>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是<strong>继承复用的基石</strong>，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。<strong>实现开闭原则的关键步骤就是抽象化</strong>，而基类与子类的继承关系就是抽象化的具体实现，所以<strong>里氏代换原则是对实现抽象化的具体步骤的规范</strong>。<br><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong><br>这个原则是<strong>开闭原则的基础</strong>，具体内容：针对接口编程，依赖于抽象而不依赖于具体。<br><strong>4、接口隔离原则（Interface Segregation Principle）</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，<strong>其实设计模式就是从大型软件架构出发</strong>、便于升级和维护的软件设计思想，它强调<strong>降低依赖，降低耦合</strong>。<br><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong><br>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。<br><strong>6、合成复用原则（Composite Reuse Principle）</strong><br>合成复用原则是指：尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringIOC的实现依赖注入</title>
      <link href="/2021/04/22/SpringIOC%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/04/22/SpringIOC%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringIOC的实现依赖注入"><a href="#SpringIOC的实现依赖注入" class="headerlink" title="SpringIOC的实现依赖注入"></a>SpringIOC的实现依赖注入</h2><p> Spring的实现依靠的是依赖注入（DI dependency injection），Spring底层创建对象，使用的是反射机制。</p><span id="more"></span><p> 讲到这里提一下创建对象的几种方法：</p><ul><li>构造方法</li><li>反射</li><li>序列化</li><li>克隆</li><li>IOC</li><li>动态代理</li></ul><hr><h4 id="基于XML的DI"><a href="#基于XML的DI" class="headerlink" title="基于XML的DI"></a>基于XML的DI</h4><p>Spring中最原始的创建对象的方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.指定Spring配置文件的名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">config</span> <span class="operator">=</span> <span class="string">&quot;beans.xml&quot;</span>;</span><br><span class="line"><span class="comment">//2.创建表示Spring容器的对象，ApplicationContext</span></span><br><span class="line"><span class="comment">//ApplicationContext--&gt;Spring容器，通过其获取对象</span></span><br><span class="line"><span class="comment">//ClassPathXmlApplicationContext--&gt;从类路径中加载Spring配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(Config);</span><br><span class="line"><span class="comment">//3.获取对象</span></span><br><span class="line"><span class="comment">//SomeService是配置文件中bean的id值</span></span><br><span class="line"><span class="type">SomeService</span> <span class="variable">service</span> <span class="operator">=</span> (SomeService) ac.getbean(<span class="string">&quot;SomeService&quot;</span>);</span><br></pre></td></tr></table></figure><p>不过这并不是Spring真正创建对象的步骤，而是在使用Spring框架时，在Spring容器中取出它后台已经创建好了的对象，看起来像是新创建的，实则只是创建了Spring容器的对象，在容器中获取真正的对象。Spring默认创建对象的时间是：在创建Spring容器时，会创建配置文件中的所有对象，创建时会默认调用<strong>无参构造方法</strong>。</p><hr><p><strong>设值注入：</strong></p><p> 通过调用set方法注入。</p><p> 在resource中“Alt+insert”选择”XML Configuration File&#x2F;Spring Config“，新建applicationContext.xml文件，bean标签中有property赋值。注意：一个property只能给一个属性赋值。例如：</p><p> 以下是基础类型的Set注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="type">bean</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;xx&quot;</span> class = <span class="string">&quot;yyy&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="type">property</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span> value = <span class="string">&quot;张三&quot;</span>/&gt;   <span class="comment">//name是对象的类型的名字，value是该类型的值</span></span><br><span class="line">    &lt;<span class="type">property</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;age&quot;</span> value = <span class="string">&quot;20&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 引用类型的Set注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="type">bean</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;xx&quot;</span> class = <span class="string">&quot;yyy&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="type">property</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span> value = <span class="string">&quot;张三&quot;</span>/&gt;   </span><br><span class="line">    &lt;<span class="type">property</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;age&quot;</span> value = <span class="string">&quot;20&quot;</span>/&gt;</span><br><span class="line">    &lt;<span class="type">property</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;属性名称&quot;</span> ref = <span class="string">&quot;bean的id(对象名称)&quot;</span>&gt; <span class="comment">//引用类型的值用&quot;ref&quot;表示</span></span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 关于引用类型的注入，ref就相当于还未找到数据的源头，他将会继续寻找ref的值得bean文件得到更“深层”的数据。</p><hr><p><strong>构造注入：</strong></p><p> Spring调用类的有参构造方法，在创建对象的同时，在构造方法中给属性赋值。</p><p> 构造注入使用**&lt;constructor -arg&gt;**标签，一个&lt;constructor -arg&gt;标签表示构造方法一个参数。</p><p> &lt;constructor -arg&gt;标签属性：</p><ul><li><p>name：表示构造方法的形参名；</p></li><li><p>index：表示构造方法的参数设置，参数从左往右依次为0,1,2…</p></li><li><p>value：构造方法的形参类型是简单类型的就使用value；</p></li><li><p>ref：构造方法的形参类型是引用类型的就使用ref。</p><p>其中，name属性和index属性构造是两种构造方法，二选一即可。其中的参数位置可以变换，不必完全按照类中的构造参数顺序排列，因为Spring的底层已经为我们构造好了。在使用index属性构造时，可以省略index的信息，但是这个时候参数的位置就必须按照0&#x2F;1&#x2F;2来排列。在实际开发中用<strong>name</strong>构造的方式还是要多一点，也是推荐的。</p></li></ul><hr><p><strong>自动注入：</strong></p><p> 引用类型的自动注入，Spring框架根据某些规则（我还不会）给引用类型赋值。</p><p> 使用的规则常用byName、byType。</p><p><strong>1.byName（按名称注入）：</strong></p><p> java类中引用类型的属性名和Spring容器中（配置文件）&lt; bean&gt;的id名称一样，且数据类型一致，这样容器中的bean、Spring可赋值给引用类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="type">bean</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;xx&quot;</span> class = <span class="string">&quot;yyy&quot;</span> autowire = <span class="string">&quot;byName&quot;</span>&gt;</span><br><span class="line">    简单类型属性赋值</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"> <span class="comment">//引用的对象   </span></span><br><span class="line">&lt;<span class="type">bean</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span> class = <span class="string">&quot;yyy&quot;</span>&gt;    <span class="comment">//name要和java类中的属性名一样</span></span><br><span class="line">    简单类型属性赋值</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>2.byType（按类型注入）：</strong></p><p> java类中引用类型的数据类型和Spring容器中（配置文件）&lt; bean&gt;的class属性是同源（同源是一类的意思）关系，这样的bean可赋值给引用类型。</p><p>同源：</p><ul><li>java类中引用类型的数据类型和bean的class值是一样的。</li><li>java类中引用类型的数据类型和bean的class是父子类关系。</li><li>java类中引用类型的数据类型和bean的class是接口和实现类的关系。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记</title>
      <link href="/2021/04/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/04/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring学习笔记"><a href="#Spring学习笔记" class="headerlink" title="Spring学习笔记"></a>Spring学习笔记</h2><p> Spring框架是一个开放源代码的J2EE应用程序框架，由Rod Johnson发起，是针对bean的生命周期进行管理的轻量级容器。它解决了开发者在J2EE开发中遇到许多常见的问题，提供了功能强大IOC、AOP及Web MVC等功能。</p><span id="more"></span><p> 作为一个开发者，对Spring的学习必定是存在困难的，但是正是由于复杂的机制和其分层的体系结构，学习好Spring框架对于自身的提升也很有帮助。</p><p> Spring具有的两大特性，<strong>控制反转（IOC）<strong>和</strong>面向切面（AOP）</strong>。</p><hr><p><strong>控制反转：</strong></p><p> Spring通过这一技术促进了低耦合。一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象，即容器在初始化时不等对象请求就主动将依赖传给他。他的底层运用了工厂模式，所有的Bean都需要注册到Bean工厂中，将其初始化和生命周期的监控都交给工厂实现管理。这就意味着在开发过程中，设计的类将交由容器去控制，而不是在类的内部去控制，类与类之间的关系也将交由容器去处理，一个类需要调用另一个类时，只要调用另一个类在容器中注册的名字就可以得到这个类的实例，与传统的编程方式有很大不同。“不用你找，我来提供给你”，这大概就是控制反转的意思。</p><hr><p><strong>面向切面AOP（Aspect Oriented Program）：</strong></p><p> 这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。</p><p> 我们知道面向对象编程的特点是继承、封装和多态。封装就是要求将功能分散到不同的对象中去，这在软件设计中叫做职责分配。实际就是，不同的类设计不同的方法，这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使得类可以重用。但是，在分散代码的同时，也增加了代码的重复性。就好比我们在两个类中都需要在每个方法中做日志，按照面向对象的思路，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但是因为面向对象的设计让他们类与类之间无法联系，而不能将这些重复的代码统一起来。</p><p> 这个时候会想，我们可以将这段相同的代码写在一个独立的类独立的方法里，然后再在这两个类中调用。话虽如此，但是这样做这两个类和上述单独的类就有耦合了，它的改变会影响这两个类。这个时候，<strong>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2021/04/06/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/04/06/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p> 链表反转是每一个接触到数据结构链表的人都必须掌握的知识，因为方法比较讨巧，对于初学者来说是比较容易绕进去，因此，特地记录一下当初学链表反转的思路。</p><span id="more"></span><p><strong>1.1定义结点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss Node&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//存储元素</span></span><br><span class="line"><span class="keyword">public</span> T item;</span><br><span class="line">    <span class="comment">//指向下一个结点</span></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.2反转思路：</strong></p><ol><li>调用reverse(Node cur)方法反转每一个结点，从元素1结点开始；</li><li>如果发现cur还有下一个结点，则递归调用reverse(cur.next)对下一个结点进行反转；</li><li>最终递归的出口是最后一个结点，因为他没有下一个元素了，当到了出口处，让head指向最后一个元素结点；</li><li>最后递归返回。</li></ol><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(Node Cur)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(cur.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> reverse(cur.next);</span><br><span class="line">    pre.next = cur;  <span class="comment">//pre是原链表中cur的下一个结点</span></span><br><span class="line">    cur.next = <span class="literal">null</span>; <span class="comment">//cur是返回的结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2021/04/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/04/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序思路：</strong></p><p> 快排的思路类似于归并排序，只不过他的基准点不是数组中间的元素，而是随机找的一个元素，可以是数组的第一个元素，而且快排的元素比较思路也略有不同，归并是先分，再治，最后合并，快排是在分的同时就已经在治了，分到最后刚好顺序排好，只要合并即可。</p><span id="more"></span><ol><li>首先定位一个基准点；</li><li>从基准点第二位开始从左往右找比基准点大的数，从数组最后一位加1从右往左找比基准点小的数，然后交换二者的位置，当left&#x3D;right时，将基准点和这个位置的元素交换，此时，比基准点小的元素在基准点左边，比基准点大的元素都在基准点右边；</li><li>以基准点为切分成左右两个数组，重复1.2的步骤，直到无法继续位置，此时数组已经排序好了。</li></ol><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">sort(a, lo , hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(a, lo ,hi);</span><br><span class="line">sort(a, lo, partition - <span class="number">1</span>);</span><br><span class="line">sort(a, partition + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> a[lo];</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> lo;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> hi + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(key &lt; a[--right]) &#123;</span><br><span class="line"><span class="keyword">if</span>(right == left) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(key &gt; a[++left]) &#123;</span><br><span class="line"><span class="keyword">if</span>(right == left) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">exch(a, left, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">exch(a, lo, right);</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i,<span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">a[j] = a[i];</span><br><span class="line">a[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>最好的情况：</p><p> 快速排序的一次划分算法从两头交替搜索，直到low和high重合，因此时间复杂度是O(n)；而整个快速排序算法的时间复杂度和划分的趟数有关；理想的情况是，每次划分所选择的中间数恰好将当前序列几乎等分，经过logn趟划分，可以得到长度为1的子表，这样整个算法的时间复杂度即为O(nlogn)。</p><p>最坏的情况：</p><p> 每次所选择的中间数都是当前序列最大或最小的元素，这使得每次划分得到的子表中一个为空表，另一个为原表的长度减1 的表，这样长度为n的数据表经过n趟划分，使得整个算法的时间复杂度为O(n^2)。</p><p> 可以证明快排的平均时间复杂度为O(nlogn)。（权威证明，具体证明暂时未知）</p><p> 不过，从空间上看快排只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归。最好的情况下，所需栈的深度为log(n+1);但是最坏的情况下，栈的深度为n，这样快排的空间复杂度为O(logn);</p><p><strong>算法稳定性：</strong></p><p> 由于快排的思路是将所有比基准数小的摆放于基准前面，所有比基准大的摆放在基准后面，这就导致相同的数会存在于基准的任何一边，在这个分区退出之后，基准处于中间，就有可能导致和基准一样数值大小的数与基准交换了位置，所以快速排序是<em><strong>不稳定</strong></em>的排序算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2021/04/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/04/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="1-1递归"><a href="#1-1递归" class="headerlink" title="1.1递归"></a>1.1递归</h3><p><strong>定义：</strong></p><p> 定义方法时，在方法内部调用方法本身，称之为递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;aaa&quot;</span>); </span><br><span class="line">    show();               <span class="comment">//这是不合格的递归，因为他会无限调用这个方法，没有结束的标志。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>作用：</strong></p><p> 他通常把一个大型的复杂问题，层层转化为一个与原问题相似的，规模较小的问题来求解。递归只需要少量的程序可以描述出多次重复的计算，极大地较少了代码量。</p><p><strong>注意：</strong></p><p> 在递归中，不能无限的调用自己，必须有边界条件，可以使得递归结束。这是因为，每一次递归的调用会在栈内存中开辟新的空间，重新执行方法，如果递归的层级太深，很容易导致栈内存溢出。</p><hr><h3 id="1-2归并排序"><a href="#1-2归并排序" class="headerlink" title="1.2归并排序"></a>1.2归并排序</h3><p><strong>归并排序思路：</strong></p><ol><li>尽可能的一组数据拆分成两个元素相等的子组，并对没一个子组继续拆分，知道拆分后的每个子组的元素个数是1为止。</li><li>将相邻的两个子组进行合并成一个有序的大组；</li><li>不断地重复步骤2，直到最终只有一个组为止。</li></ol><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] assit;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">assit = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line"><span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">sort(a, lo, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">sort(a, lo, mid);</span><br><span class="line">sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">merge(a, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> lo;</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= hi) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[p1] &lt; a[p2]) &#123;</span><br><span class="line">assit[i ++] = a[p1 ++];</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">assit[i ++] = a[p2 ++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">assit[i ++] = a[p1 ++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2 &lt;= hi) &#123;</span><br><span class="line">assit[i ++] = a[p2 ++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;index &lt;= hi;index ++) &#123;</span><br><span class="line">a[index] = assit[index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p> 通过代码可以看出，归并排序事先定义了一个辅助的数组来进行排序，相当于开辟了空间，是经典的用空间换取算法时间的做法。对于时间复杂度，可以用树形图来看，归并排序将数组每次对半分，这样就会有logn层，第k层包含2^k个数组，每个数组包含2^(logn-k)个元素，所以需要比较2^k*2^(logn-k)次，即2^(logn)次，一共有logn层，所以一共比较2^(logn)xlogn次，即时间复杂度为O(nlogn)。</p><p><strong>算法稳定性：</strong></p><p> 由于交换的只是较小的元素，所以不存在同等大小元素的位置改变的情况，所以此算法是<em><strong>稳定性</strong></em>算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单排序算法</title>
      <link href="/2021/03/28/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/03/28/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简单排序算法"><a href="#简单排序算法" class="headerlink" title="简单排序算法"></a>简单排序算法</h2><h3 id="1-1冒泡排序"><a href="#1-1冒泡排序" class="headerlink" title="1.1冒泡排序"></a>1.1冒泡排序</h3><p><strong>冒泡排序算法思路：</strong></p><span id="more"></span><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们的位置；</li><li>对每一对相邻的元素做同样的工作，从开始第一对到结尾最后一对。一趟排序后，最大的元素会被放到最后一位；</li><li>针对所有的元素重复以上的步骤（除了最后一个）；</li><li>每一趟持续的元素越来越少，直到没有元素需要比较。</li></ol><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubble(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i ++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;           <span class="comment">//把较大的元素放到后一位</span></span><br><span class="line">temp = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>优化之后：</strong></p><p> 但是这种会有一个弊端，即如果一趟下来，没有元素交换的话（说明此数组已经排序好了），他还会继续完成剩余的比较，导致浪费了时间。所以可以添加标志位进行优化，即一趟排序中发生了元素交换，则将标志位置1，没有出现元素交换将标志位置0，若标志位为0就说明此数组已经排序好了。</p><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubble(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i ++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">temp = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) &#123;             <span class="comment">//判断元素是否发生交换的标志位</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>时间复杂度：</strong></p><p> 最好的情况：文件的初始状态就是正序的，那么一趟扫描即可完成排序。所需的比较次数为n-1，元素移动次数为0，所以最好的时间复杂度为O(n)；</p><p> 最坏的情况：文件的初始状态是反序的，需要进行n-1排序。每趟排序要进行n-i次关键字的比较，每次比较需要移动3次元素交换位置。最坏的时间复杂度为O(n^2)；</p><p> 综上，冒泡排序的时间复杂度为O(n^2)；</p><p><strong>算法稳定性：</strong></p><p> 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<em><strong>稳定排序</strong></em>算法。</p><h3 id="2-2选择排序"><a href="#2-2选择排序" class="headerlink" title="2.2选择排序"></a>2.2选择排序</h3><p><strong>选择排序算法思路：</strong></p><ol><li>每次排序后选择最小的元素与前面的位置进行交换，</li><li>经过数次排序后完成。</li></ol><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectSort(<span class="type">int</span>[] a) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; a.length - <span class="number">1</span>;i ++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; a.length;j ++) &#123;  <span class="comment">//找到最小元素和对应的下标</span></span><br><span class="line"><span class="keyword">if</span>(a[j] &lt; a[i]) &#123;</span><br><span class="line">minIndex = j;</span><br><span class="line">min = a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(minIndex != i) &#123;              <span class="comment">//发生了最小元素的切换，就交换位置</span></span><br><span class="line">a[minIndex] = a[i];</span><br><span class="line">a[i] = min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>时间复杂度：</strong></p><p> 选择排序的交换操作介于 0 和 (n - 1)次之间。选择排序的比较操作为 n (n - 1） &#x2F; 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N&#x3D;(n-1）+(n-2）+…+1&#x3D;n*(n-1）&#x2F;2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n&#x2F;2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。但是时间复杂度依然是O(n^2)。</p><p><strong>算法稳定性：</strong></p><p> 选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个<em><strong>不稳定排序</strong></em>算法。</p><h3 id="2-3插入排序"><a href="#2-3插入排序" class="headerlink" title="2.3插入排序"></a>2.3插入排序</h3><p><strong>插入排序算法思路：</strong></p><p> 假设前面n-1(其中n&gt;&#x3D;2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertSort(<span class="type">int</span>[] a) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length;i ++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> a[i];</span><br><span class="line"><span class="keyword">while</span>(insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; a[insertIndex]) &#123;</span><br><span class="line">a[insertIndex + <span class="number">1</span>] = a[insertIndex];</span><br><span class="line">insertIndex --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(insertIndex + <span class="number">1</span> != i) &#123;</span><br><span class="line">a[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>时间复杂度：</strong></p><p> 最好的情况：在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为O(n)；</p><p> 最坏的情况：待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为O(n^2)；</p><p> 综上，插入排序的时间复杂度为O(N^2)。</p><p><strong>算法稳定性：</strong></p><p> 该算法是<em><strong>稳定性</strong></em>算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流水线问题</title>
      <link href="/2021/03/26/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2021/03/26/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="流水线问题"><a href="#流水线问题" class="headerlink" title="流水线问题"></a>流水线问题</h2><p> 某企业拥有4条流水生产线A、B、C、D，每条流水线目前每月的生产量在10、7、 5、4吨。现企业需要优化各流水线，故实行每月末从生产最多的流水线中抽出3吨 的生产力，分配到剩余的3条流水线里，既其余每条流水线多生产1吨，这称为一次 生产力优化(既经过第一个月后的优化，各流水线生产吨数在:7、8、6、5)<br>那么请问，经过五年的生产力优化调整后，哪个流水线生产力最高，可每月生产多少吨？<br>编程求解该问题，并思考是否为最优解。</p><hr><span id="more"></span><p>思路如下：</p><p> 4条流水线对应A,B,C,D,刚好用数组的0,1,2,3代替，其实质对数组进行5次操作，每次操作找到数组的最大值，将其减3，其余元素则对应加1；最后输出该数组的索引和该索引下的值即可。由于解法是纯粹的数组的操作，所以使用的空间和时间会稍微复杂一点，应该不是最优解；如果想寻求快速且利用空间更少，可以使用hashmap，在比较时不用再创建数组，可以节约时间和空间。</p><hr><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Answer1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] lines = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++) &#123;</span><br><span class="line">optimize(lines);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] ans = getMax(lines);</span><br><span class="line">System.out.println(<span class="string">&quot;流水线&quot;</span> + (<span class="type">char</span>)(ans[<span class="number">1</span>] + <span class="number">65</span>) + <span class="string">&quot;生产力最高 &quot;</span> + <span class="string">&quot;可每月生产&quot;</span> + ans[<span class="number">0</span>] + <span class="string">&quot;吨&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数是优化函数，将最大的元素减3，其余的各自加1即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] optimize(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"><span class="type">int</span>[] arrnew = getMax(arr);              <span class="comment">//得到当前数组最大的元素和对应索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i ++) &#123;     <span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">if</span>(i == arrnew[<span class="number">1</span>]) &#123;                 <span class="comment">//最大的元素减3</span></span><br><span class="line">arr[i] = arr[i] - <span class="number">3</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">arr[i] = arr[i] + <span class="number">1</span>;                 <span class="comment">//其余的元素加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到该数组的最大值和最大值对应的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getMax(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里是以防传进来的数组为空或者长度为0时的边界条件，由于传进来的数组必不为空，所以忽略；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//if(arr == null || arr.length == 0) &#123;</span></span><br><span class="line"><span class="comment">//return null;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;                      <span class="comment">//假设第一个元素是最大值,所以索引设为0</span></span><br><span class="line"><span class="type">int</span>[] newarr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];             <span class="comment">//用作记录最小值和对应的索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;arr.length - <span class="number">1</span>;i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[maxIndex] &lt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">maxIndex = i + <span class="number">1</span>;              <span class="comment">//将索引变成较大值的索引</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">newarr[<span class="number">0</span>] = arr[maxIndex];</span><br><span class="line">newarr[<span class="number">1</span>] = maxIndex;</span><br><span class="line"><span class="keyword">return</span> newarr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找相邻最大元素</title>
      <link href="/2021/03/26/%E5%AF%BB%E6%89%BE%E7%9B%B8%E9%82%BB%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>/2021/03/26/%E5%AF%BB%E6%89%BE%E7%9B%B8%E9%82%BB%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="寻找相邻最大元素"><a href="#寻找相邻最大元素" class="headerlink" title="寻找相邻最大元素"></a>寻找相邻最大元素</h2><p>题目描述：</p><p>给定一个数组，例如[15, 2, 8, 13]，找到符合下面方式的结果，并打印出来 例如: 1)从数组每位元素当前位置开始，往后找到大于自己本身的第一位元素，并返回 1)如果没有找到，返回-1<br>结果如下<br>15 -&gt; -1<br>2 -&gt; 8<br>8 -&gt; 13<br>13 -&gt; -1 返回结果:<br>要求:除了编码实现，需给出时间复杂度，并说明最坏情况(可考虑栈)</p><hr><span id="more"></span><p>解题思路：</p><p> 这题的思路本来是直接两层循环搞定，但是考虑到两层循环时间复杂度是O(n^2)，最坏的情况就是数组中的元素递减至最后一位，最后一位是该数组的最大值，相当于第二层循环每次都会遍历到数组最后一位元素。</p><p> 于是想到用栈，由于是先进后出，依次把数组中的索引入栈，接下来比较数组的值和栈顶索引对应的值，要是若是数组元素值小，则直接入栈索引，否则出栈，对应的值为比较的值，出栈后以相同规则继续比较，最后栈中还有其他元素，则全部出栈，对应-1；由于只遍历一遍数组，时间复杂度是O(n)。</p><p> 这里用数组实现栈的基本功能。</p><hr><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Answer2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入数组的长度：&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">arr[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">sc.close();</span><br><span class="line"><span class="type">int</span>[] ans = findNextBigger(arr);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i ++) &#123;</span><br><span class="line">System.out.println(arr[i] + <span class="string">&quot; &quot;</span> + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot; &quot;</span> + ans[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找到每个元素后面相邻最近的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findNextBigger(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 边界条件，由于传入的数组必不为空，所以取消</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//if(arr == null || arr.length == 0) &#123;</span></span><br><span class="line"><span class="comment">//return null;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当传入数组只有一个值时，直接返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(arr.length == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span>[] ans = &#123;-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arrNew = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];    <span class="comment">//用于接收结果的数组</span></span><br><span class="line"><span class="type">Answer2</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Answer2</span>();</span><br><span class="line"><span class="type">Stack</span> <span class="variable">stack</span> <span class="operator">=</span> t.<span class="keyword">new</span> <span class="title class_">Stack</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i ++) &#123;</span><br><span class="line"><span class="comment">//最开始或者数组元素不大于栈顶对应的元素，入栈索引</span></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty() || arr[i] &lt;= arr[stack.peek()]) &#123;         </span><br><span class="line">stack.push(i);       </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//栈非空的情况下 数组元素比栈顶对应的元素大，出栈索引，将对应的值存入新的数组</span></span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[i] &gt; arr[stack.peek()]) &#123;  </span><br><span class="line">arrNew[stack.pop()] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">stack.push(i);     <span class="comment">//数组元素索引入栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty()) &#123;  <span class="comment">//最后留在栈中的元素全部出栈，此时新的数组全部填入-1</span></span><br><span class="line">arrNew[stack.pop()] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arrNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.使用数组当作储存数据的底层结构</span></span><br><span class="line"><span class="comment"> * 2.实现数组的LIFO(Last in First out)</span></span><br><span class="line"><span class="comment"> * 3.可以知道stack的顶层元素，可以入栈，出栈 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="comment">// 底层储存载体</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] theArray;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化栈,刚开始栈顶应该在0处</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">theArray = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回栈的大小，如果为空栈则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (theArray.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> theArray.length;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈判空，空返回true，反之false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(theArray.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容，每次的扩容量为1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> lenth)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] oldTheArray = theArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lenth &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span>[] newTheArray = <span class="keyword">new</span> <span class="title class_">int</span>[theArray.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= oldTheArray.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">newTheArray[i] = oldTheArray[i];</span><br><span class="line">&#125;</span><br><span class="line">theArray = newTheArray;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span>[] newTheArray = <span class="keyword">new</span> <span class="title class_">int</span>[theArray.length - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= newTheArray.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">newTheArray[i] = oldTheArray[i];</span><br><span class="line">&#125;</span><br><span class="line">theArray = newTheArray;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"></span><br><span class="line">ensureCapacity(<span class="number">1</span>);</span><br><span class="line">theArray[size() - <span class="number">1</span>] = i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出栈，如果栈为空则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(theArray.length&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;stack is empty&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">popValue</span> <span class="operator">=</span> theArray[size() - <span class="number">1</span>];</span><br><span class="line">ensureCapacity(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> popValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回栈顶元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> theArray[size() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长12相间子串</title>
      <link href="/2021/03/26/%E6%9C%80%E9%95%BF12%E7%9B%B8%E9%97%B4%E5%AD%90%E4%B8%B2/"/>
      <url>/2021/03/26/%E6%9C%80%E9%95%BF12%E7%9B%B8%E9%97%B4%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="最长12相间子串"><a href="#最长12相间子串" class="headerlink" title="最长12相间子串"></a>最长12相间子串</h2><p>题目描述：</p><p> 有一段12组成的字符串，例如”1212111212”，可进行0或多次的一下规律:从某一位 置分隔成两个字符串，两个字符串同时翻转后在拼接。找出最⻓的连续12相间的⻓度。<br>例如:<br>1212111212 假设从第五、六位分隔 12121, 11212 翻转后 12121 , 21211 拼接后 1212121211 这个时候的连续12相间的⻓度为9，也是最⻓的连续12相间的。</p><hr><span id="more"></span><p>解题思路：</p><p> 这题一开始的思路是尝试暴力破解然后优化，但是发现翻转字符串可以有无限次的操作，所以这个方向是错误的。然后注意到子串反转之后再拼接，其中的数组索引还是连续的，于是经过翻转几次验证了一下，无论翻转多少次，数组的索引永远是连续的一组数据，也就是说，只要在原来的字符串后面拼接原串应该就是所有的翻转结果了。最后得到的数据要小于等于原来子串的长度。</p><hr><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Answer3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + s1;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> size(s);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回字符串最大相间子串的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length() - <span class="number">1</span>;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(i + <span class="number">1</span>)) &#123; <span class="comment">//如果相邻元素不一样，则将size+1</span></span><br><span class="line">                size ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(size &gt; sum)&#123;                  <span class="comment">//如果相邻元素一样且大于之前的sum，则更新sum的值，将size置1再次比较</span></span><br><span class="line">                    sum = size;</span><br><span class="line">                &#125;</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(size == s.length() / <span class="number">2</span>) &#123;             <span class="comment">//如果原串本身就是最长12相间的子串，则size会是两倍原串的长度，sum会是0</span></span><br><span class="line">        sum = size / <span class="number">2</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x的悲剧</title>
      <link href="/2021/03/25/x%E7%9A%84%E6%82%B2%E5%89%A7/"/>
      <url>/2021/03/25/x%E7%9A%84%E6%82%B2%E5%89%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="《X的悲剧》"><a href="#《X的悲剧》" class="headerlink" title="《X的悲剧》"></a>《X的悲剧》</h2><p> <strong>侦探小说门外汉的记录</strong></p><p> <strong>可能剧透！</strong></p><p> 第一次听说埃勒里奎因还是《唐人街探案》里刘昊然说的奎因手稿，之后在论坛上又听说了埃勒里奎因的鼎鼎大名，恰逢京东悲剧系列打折，种种机缘巧合之下，把这系列买了下来，经过数天的零碎时间闲读，终于把《X的悲剧》读完。</p><span id="more"></span><p> 接触到这本书之后我才发现埃勒里奎因竟然是兄弟俩的笔名，兄弟俩一个设计诡计，一个负责文笔，实在是太有意思了。</p><p> 阅读完这本书，和我之前看的《占星术杀人魔法》感觉是两种风格。这本会把案子的细节抽丝剥茧般地完全呈现在你面前，甚至线索证据也已经告诉你了，但是奈何本书中有三个连环案，碎片化信息太多，要想把这么多的信息完全处理成一条线连接起来，对于读者来说难度太大，但是本书中的侦探——哲瑞雷恩则是一步步把真相呈现在读者面前。</p><hr><p> 接下来讲一讲看法：</p><p> 这本书主要讲的是复仇的故事。多年前（年轻的地质学者）史托普和同伴柯洛奇在异国采矿，史托普成功探到了锰矿，但是没钱开采。于是柯洛奇牵线联系了隆斯崔和德威特出钱。但是柯洛奇酒后觊觎史托普年轻妻子的美色，但是抗死不从被残忍杀害，另一个恶魔隆斯崔就怂恿他污蔑史托普，刚好把锰矿也据为己有，德威特在威逼利诱下也同意了。</p><p> 这三位在事成之后把矿卖了回到美国，其中柯洛奇去向不明。多年后史托普越狱回到美国开始他的复仇计划。将三个人在布置紧密的计划中杀害。</p><p> 尽管史托普最终复仇成功，但是他的人生就这样被毁于一旦，他唯一做错的事情就是认识了柯洛奇，交友不慎就会跌入万丈深渊。其中篇幅较多的就是德威特，朋友们都对他的评价很高，聪明睿智，冷静理性，然而这位老好人在当年的史托普案里什么也没有做，成为了恶灵的同伙，没有自己的主见，没有勇气对抗，导致后来回国之后他也永远像拖着一块巨石踽踽前行，被另外两个恶魔折磨着，他没有认清，也没有做到向恶对抗，这是他最大的人格缺陷。</p><p> 恶是不分主次的，也不管大小。善良也不应该被恶所胁迫。小说中史托普对他下手最轻，一枪就结束了他的生命，这也是对他们三人罪罚的衡量吧。</p><hr><p> 最后，希望自己不要像德威特一样，做那样的烂好人，永远怂在真正的恶灵之前，应该有自己的道德底线，和敢于对抗恶的勇气，切忌一步一步地把自己的底线磨平。剧中德威特最后想反抗，勇敢面对自己的恶的时候，他的生命戛然而止，永远没有了机会。不要等到最后才说后悔。****</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>占星术杀人魔法</title>
      <link href="/2021/03/22/%E5%8D%A0%E6%98%9F%E6%9C%AF%E6%9D%80%E4%BA%BA%E9%AD%94%E6%B3%95/"/>
      <url>/2021/03/22/%E5%8D%A0%E6%98%9F%E6%9C%AF%E6%9D%80%E4%BA%BA%E9%AD%94%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="《占星术杀人魔法》"><a href="#《占星术杀人魔法》" class="headerlink" title="《占星术杀人魔法》"></a>《占星术杀人魔法》</h2><p> <strong>侦探小说门外汉的记录</strong></p><p> <strong>可能剧透！</strong></p><p> 最近一段时间陆陆续续地把岛田庄司的《占星术杀人魔法》给读完了。想起来也不是非得写这个博客不可，但是博客都搭建好了，也就自己弄弄，算是给以后的自己留点回味的东西吧。</p><p> 最初选择这本书的时候可谓是大费周章，因为之前并没有接触推理小说的经验，但是在论坛上看大家的推荐都说这本出自岛田庄司之手的《占星术杀人魔法》是日本推理小说本格派的经典！于是果断出击，把它拿下！</p><span id="more"></span><p> 经过很多个晚上抽时间读（原谅我平时充电太杂了没什么时间看），看到凶手的作案手法揭晓那一块我就有点震撼了，原来岛田这个人写作案手法可以隐藏的这么深，真的是完完全全的推理，我也惊讶于都已经用制作假钱这么明显的线索来告知读者了，竟然浑然不知，我还天真的以为用不透明的胶带沾钱只是胶带便宜罢了。</p><hr><p> 接下来讲一讲看法：</p><ul><li><p>在诡计上，一点没有繁琐费脑的机关，也没有多琐碎的诡计叙述，案件描述的也是细致入微。岛田庄司身为新本格的奠基人，这部作品的诡计真的设置的精妙绝伦，更可恨的是书名的占星术杀人魔法也直接误导读者，将诡计藏的非常之深，看到最后揭晓的时候有种“恍然大明白”的感觉。</p></li><li><p>在情节设计上，水的太多了，中间有很大的篇幅都是石岗带着读者的思路到处跑，导致读者的思维很容易被牵着走，到最后发现他所做的和破案基本没什么联系，整体看下来感觉情节不是特别连贯。</p></li><li><p>整个案件，凶手的动机和最后的自白非常的朴实细致，没有社会派那些令人唏嘘的感觉，就只有原来凶手也不是那种十恶不赦之人，有着自己的苦衷和自己的想法，在最后得知凶手长久以来的遭遇之后我甚至觉得有一点感人。</p></li><li><p>总的来说，对于我一个刚入门的来看，这部小说除了有点水量以外真的很有阅读体验，看侦探小说图的就是“恍然大悟”“原来是这样的”感觉，当然我还是希望以后我能看出点门道。同时这本书我应该不会看第二遍了，核心诡计已经知道之后，这里面推理的玩味性已经没有多少了。</p><hr><p>最后，看完这本书之后阴差阳错地听到了林俊杰的《妈妈的娜鲁娃》，一时间循环了很多遍，朦胧中就营造了一种画面，在夕阳照着日本那标志性的平屋前面的草坪，顺着草坪下去的斜坡，一条小河蜿蜒地流着，时子站在屋前，面对着洒过来的夕阳，应该在想念她的母亲吧，“风中的百合花，还会不会长大”，谁又能知道呢。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
